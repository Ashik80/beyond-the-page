<div class="flex justify-center pt-2 pb-3">
  <div id="auth-best-practice-container" class="container">
    <h1>Secure Auth with OAuth2.0</h1>
    <p>
      When dealing with JWT tokens we are often faced with the dillema of where
      to store the access token. Most of the time we store it in the browser
      localstorage and forget about it. Every tutorial that I've seen tells us
      that it is not a good practice to store it in the localstorage but does
      not tell us what to do with it. And I understand why. It is upto the
      person implementing it to secure the application as they see fit. In this
      article I'll talk about one of the ways which I implemented this and will
      be explicitly focusing on how to secure your application with OAuth2.0
      refresh tokens. If you have an application that uses OAuth2.0, AWS Cognito
      or anything that builds on OAuth 2.0 for authentication/authorization you
      can read on.
    </p>
    <h2>Understanding the different types of tokens</h2>
    <p>
      The first and easy step is to get the tokens generated by OAuth. You just
      hit the OAuth endpoint and end up with three types of tokens. The
      <strong>ID token</strong>, <strong>access token</strong> and the
      <strong>refresh token</strong>.
    </p>
    <p>
      <strong>ID tokens</strong> are supposed to be decoded and kept in the
      client side. You can encode some information about a user in it such as
      the email, first name, last name etc. on it. And you can keep it anywhere
      in your front end code, decode and disply it's information. It should not
      be used for authorization.
    </p>
    <p>
      <strong>Access tokens</strong>, on the other hand, is supposed to be used
      for authorization. You are supposed to pass it to the backend in a header
      to get data you are authorized for. This token should be short-lived
      because if any malicious person gets their hand on this token, they will
      be able to access restricted contents meant for that user. But if the
      access token is so short-lived (let's say it expires in 10 minutes) the
      user will have to keep logging in after every 10 minutes and that's not a
      good experience. That's where the refresh token comes in.
    </p>
    <p>
      <strong>Refresh tokens</strong> are used get new access token every time
      the user's access token expires or is missing. A refresh token's expiry
      time is usually long enough to give users a good experience on the
      application. It's usually stored in secured cookies. There are ways to
      make a cookie secure as we will see in the implementaion section.
    </p>
    <h2>An example Implementaion</h2>
    <p>
      I'll not go over the detailed code and will assume we all are familiar
      with how to post data through a form. I'll just go over the part that
      deals with the tokens directly. So the idea of the flow is:
    </p>
    <ol class="pl-2">
      <li>Client calls our server endpoint with credentials</li>
      <li>Server endpoint calls oauth endpoint if credentials match</li>
      <li>
        Server gets the tokens and we save the refresh token to a cookie and
        return the id and access token to the client
      </li>
    </ol>
    <p>
      Since we are assuming we are familiar with step 1, let's skip over to the
      part where we called the OAuth endpoint and received a payload like this
    </p>
    <!-- prettier-ignore -->
    <code-block lang="json">{
  "idToken": "xxxxxxxxxx",
  "accessToken": "xxxxxxxxxx",
  "refreshToken": "xxxxxxxxxx",
  ...
}</code-block>
    <p>
      We will take the refresh token and save it to a cookie with a key
      <code>myRefreshToken</code> and send the other tokens to the client like
      in the snippet below. This cookie will be sent to the server from the
      client on every request.
    </p>
    <!-- prettier-ignore -->
    <code-block lang="typescript">res.cookie('myRefreshToken', oauthResponse.refreshToken, {
  httpOnly: true,
  maxAge: 30000000,
  secure: process.env.ENV === 'development' ? false : true,
  path: '/',
});

return res.json({
  idToken: oauthResponse.idToken,
  accessToken: oauthResponse.accessToken,
})</code-block>
    <p>
      To secure the cookie we have passed it several options.
      <strong>httpOnly</strong> set to true makes sure that the cookie cannot be
      modified by JavaScript code and can only be modified once it reaches the
      server. <strong>secure</strong> set to true will only make the cookie
      accessible from a HTTPS protocol. It did not even work for me in localhost
      and that's the reason for the condition. The
      <strong>path</strong> variable defines what should be present in the URL
      if we want to send the cookie to the server. We want our whole application
      to do it so I've set it to <code>/</code>. Refer to the
      <a
        id="mdn-doc-link-external"
        target="_blank"
        href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies"
        >MDN web docs</a
      >
      to know more about cookies.
    </p>
    <p>
      On the client, use the idToken however you see fit. But we are going to
      keep the accessToken in a normal JavaScript variable and not in the
      localstorage. We will send the accessToken in a header when making any
      authorized request.
    </p>
    <!-- prettier-ignore -->
    <code-block lang="javascript">const config = {
  headers: {
    'Content-Type': 'application/json',
    Authorization: `Bearer ${accessToken}`,
  },
};

const res = await fetch(url, config);
const data = await res.json();

return data;</code-block>
    <p>
      However, this means that a simple page refresh is going to result in no
      accessToken. We can add some logic that if we don't have access token we
      are going to request an endpoint called
      <code>/renew-access-token</code> with the refresh token in the cookie to
      get a new access token.
    </p>
    <!-- prettier-ignore -->
    <code-block lang="javascript">if (!accessToken) {
  const res = await fetch('/renew-access-token', {
    credentials: 'include', // this is required to include the cookie with the request
  });
  const data = await res.json();

  console.log(data.accessToken); // store the access token in the variable again
}</code-block>
    <p>
      In the implementation of the <code>/renew-access-token</code>, we are
      going to extract the refresh token from the cookie and use it to call
      OAuth token endpoint again. To extract the cookie from the request we will
      do this
    </p>
    <!-- prettier-ignore -->
    <code-block lang="typescript">const refreshToken = req.cookies.myRefreshToken; // remember we named the key 'myRefreshToken'
const data = fetch(oauthUrl, ....);

return res.json({
  idToken: oauthResponse.idToken,
  accessToken: oauthResponse.accessToken,
});</code-block>
    <p>
      We have successfully sent the new accessToken to the client and the client
      will be authorized again. And I'll gently remind you again that this is
      only one type of implementation and there are certainly other ones out
      there that you suite your style if this one does not.
    </p>
    <p></p>
  </div>
</div>
